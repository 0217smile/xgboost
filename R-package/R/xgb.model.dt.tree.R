#' Parse boosted tree model text dump
#' 
#' Parse a boosted tree model text dump into a \code{data.table} structure.
#' 
#' @importFrom data.table data.table
#' @importFrom data.table :=
#' @importFrom magrittr %>%
#' @importFrom stringr str_match
#' 
#' @param feature_names character vector of feature names. If the model already
#'          contains feature names, this argument should be \code{NULL} (default value)
#' @param model object of class \code{xgb.Booster}
#' @param text \code{character} vector previously generated by the \code{xgb.dump} 
#'          function  (where parameter \code{with.stats = TRUE} should have been set).
#' @param n_first_tree limit the parsing to the \code{n} first trees. 
#'          If set to \code{NULL}, all trees of the model are parsed.
#'
#' @return 
#' A \code{data.table} with detailed information about model trees' nodes.
#'
#' The columns of the \code{data.table} are:
#' 
#' \itemize{
#'  \item \code{Tree}: ID of a tree in a model
#'  \item \code{Node}: ID of a node in a tree
#'  \item \code{ID}: unique identifier of a node in a model
#'  \item \code{Feature}: for a branch node, it's a feature id or name (when available);
#'              for a leaf note, it simply labels it as \code{'Leaf'}
#'  \item \code{Split}: location of the split for a branch node (split condition is always "less than")
#'  \item \code{Yes}: ID of the next node when the split condition is met
#'  \item \code{No}: ID of the next node when the split condition is not met
#'  \item \code{Missing}: ID of the next node when branch value is missing
#'  \item \code{Quality}: either the split gain or the leaf value
#'  \item \code{Cover}: metric related to the number of observation either seen by a split split 
#'                      or collected by a leaf during training.
#' } 
#' 
#' @examples
#' data(agaricus.train, package='xgboost')
#' 
#' bst <- xgboost(data = agaricus.train$data, label = agaricus.train$label, max.depth = 2, 
#'                eta = 1, nthread = 2, nround = 2,objective = "binary:logistic")
#' 
#' xgb.model.dt.tree(colnames(agaricus.train$data), bst)
#' 
#' @export
xgb.model.dt.tree <- function(feature_names = NULL, model = NULL, text = NULL,
                              n_first_tree = NULL){
  
  if (!class(feature_names) %in% c("character", "NULL")) {
    stop("feature_names: Has to be a vector of character\n",
         "  or NULL if the model dump already contains feature names.\n",
         "  Look at this function documentation to see where to get feature names.")
  }
  
  if (class(model) != "xgb.Booster" & class(text) != "character") {
    stop("Either 'model' has to be an object of class xgb.Booster\n",
         "  or 'text' has to be a character vector with the result of xgb.dump\n",
         "  (or NULL if the model was provided).")
  }
  
  if (!class(n_first_tree) %in% c("numeric", "NULL") | length(n_first_tree) > 1) {
    stop("n_first_tree: Has to be a numeric vector of size 1.")
  }
  
  if(is.null(text)){
    text <- xgb.dump(model = model, with.stats = T)
  }
  
  position <- which(!is.na(str_match(text, "booster")))
  
  addTreeId <- function(x, i) paste(i,x,sep = "-")
  
  anynumber_regex <- "[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?"
  
  td <- data.table(t=text)
  td[position, Tree := 1L]
  td[, Tree := cumsum(ifelse(is.na(Tree), 0L, Tree)) - 1L]
  
  n_first_tree <- min(max(td$Tree), n_first_tree)
  td <- td[Tree <= n_first_tree & !grepl('^booster', t)]
  
  td[, Node := str_match(t, "(\\d+):")[,2] %>% as.numeric ]
  td[, ID := addTreeId(Node, Tree)]
  td[, isLeaf := !is.na(str_match(t, "leaf"))]
  td[isLeaf==TRUE, Feature := "Leaf"]
  td[isLeaf==FALSE, Feature := str_match(t, "f(\\d+)<")[,2] ]
  td[isLeaf==FALSE & !is.null(feature_names), Feature := feature_names[as.numeric(Feature) + 1] ]
  td[isLeaf==FALSE, Split := str_match(t, paste0("<(",anynumber_regex,")\\]"))[,2] ]
  td[isLeaf==FALSE, Yes := str_match(t, "yes=(\\d+)")[,2] %>% addTreeId(Tree) ]
  td[isLeaf==FALSE, No  := str_match(t,  "no=(\\d+)")[,2] %>% addTreeId(Tree) ]
  td[isLeaf==FALSE, Missing := str_match(t, "missing=(\\d+)")[,2] %>% addTreeId(Tree) ]
  td[isLeaf==FALSE, Quality := str_match(t, paste0("gain=(",anynumber_regex,")"))[,2] %>% as.numeric ]
  td[isLeaf==TRUE,  Quality := str_match(t, paste0("leaf=(",anynumber_regex,")"))[,2] %>% as.numeric ]
  td[, Cover := str_match(t, paste0("cover=(\\d*\\.*\\d*)"))[,2] %>% as.numeric ]
  
  td[, t := NULL]
  td[, isLeaf := NULL]

  td
}

# Avoid error messages during CRAN check.
# The reason is that these variables are never declared
# They are mainly column names inferred by Data.table...
globalVariables(c("Tree", "Node", "ID", "Feature", "Split", "Yes", "No", "Missing", "Quality", "Cover"))